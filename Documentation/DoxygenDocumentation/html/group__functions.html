<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vampireGameproject: pystring</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vampireGameproject
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pystring</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepystring_1_1os"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepystring_1_1os.html">pystring::os</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafaaa3fa41c260f26b7121397837f9073"><td class="memItemLeft" align="right" valign="top"><a id="gafaaa3fa41c260f26b7121397837f9073"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_32BIT_INT</b>&#160;&#160;&#160;2147483647</td></tr>
<tr class="separator:gafaaa3fa41c260f26b7121397837f9073"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga421839935c851d76429324b5c11d7854"><td class="memItemLeft" align="right" valign="top"><a id="ga421839935c851d76429324b5c11d7854"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga421839935c851d76429324b5c11d7854">pystring::capitalize</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga421839935c851d76429324b5c11d7854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string with only its first character capitalized. <br /></td></tr>
<tr class="separator:ga421839935c851d76429324b5c11d7854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdc4421773d4c924952ad6e66cd6868"><td class="memItemLeft" align="right" valign="top"><a id="gafbdc4421773d4c924952ad6e66cd6868"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gafbdc4421773d4c924952ad6e66cd6868">pystring::center</a> (const std::string &amp;str, int width)</td></tr>
<tr class="memdesc:gafbdc4421773d4c924952ad6e66cd6868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return centered in a string of length width. Padding is done using spaces. <br /></td></tr>
<tr class="separator:gafbdc4421773d4c924952ad6e66cd6868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cbc27163e59a6ee85e7769de27fab82"><td class="memItemLeft" align="right" valign="top"><a id="ga1cbc27163e59a6ee85e7769de27fab82"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga1cbc27163e59a6ee85e7769de27fab82">pystring::count</a> (const std::string &amp;str, const std::string &amp;substr, int start=0, int end=MAX_32BIT_INT)</td></tr>
<tr class="memdesc:ga1cbc27163e59a6ee85e7769de27fab82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of occurrences of substring sub in string S[start:end]. Optional arguments start and end are interpreted as in slice notation. <br /></td></tr>
<tr class="separator:ga1cbc27163e59a6ee85e7769de27fab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga639d2027c72c89ba412cc367132b0f2b"><td class="memItemLeft" align="right" valign="top"><a id="ga639d2027c72c89ba412cc367132b0f2b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga639d2027c72c89ba412cc367132b0f2b">pystring::endswith</a> (const std::string &amp;str, const std::string &amp;suffix, int start=0, int end=MAX_32BIT_INT)</td></tr>
<tr class="memdesc:ga639d2027c72c89ba412cc367132b0f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return True if the string ends with the specified suffix, otherwise return False. With optional start, test beginning at that position. With optional end, stop comparing at that position. <br /></td></tr>
<tr class="separator:ga639d2027c72c89ba412cc367132b0f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac878a5845823a7d9795e8b4d88e4b72f"><td class="memItemLeft" align="right" valign="top"><a id="gac878a5845823a7d9795e8b4d88e4b72f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gac878a5845823a7d9795e8b4d88e4b72f">pystring::expandtabs</a> (const std::string &amp;str, int tabsize=8)</td></tr>
<tr class="memdesc:gac878a5845823a7d9795e8b4d88e4b72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string where all tab characters are expanded using spaces. If tabsize is not given, a tab size of 8 characters is assumed. <br /></td></tr>
<tr class="separator:gac878a5845823a7d9795e8b4d88e4b72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67888cb5c63d86f3867fe93e87da3586"><td class="memItemLeft" align="right" valign="top"><a id="ga67888cb5c63d86f3867fe93e87da3586"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga67888cb5c63d86f3867fe93e87da3586">pystring::find</a> (const std::string &amp;str, const std::string &amp;sub, int start=0, int end=MAX_32BIT_INT)</td></tr>
<tr class="memdesc:ga67888cb5c63d86f3867fe93e87da3586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lowest index in the string where substring sub is found, such that sub is contained in the range [start, end). Optional arguments start and end are interpreted as in slice notation. Return -1 if sub is not found. <br /></td></tr>
<tr class="separator:ga67888cb5c63d86f3867fe93e87da3586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4ca19d0d897a49df3ca8faab1864970"><td class="memItemLeft" align="right" valign="top"><a id="gab4ca19d0d897a49df3ca8faab1864970"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gab4ca19d0d897a49df3ca8faab1864970">pystring::index</a> (const std::string &amp;str, const std::string &amp;sub, int start=0, int end=MAX_32BIT_INT)</td></tr>
<tr class="memdesc:gab4ca19d0d897a49df3ca8faab1864970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym of find right now. Python version throws exceptions. This one currently doesn't. <br /></td></tr>
<tr class="separator:gab4ca19d0d897a49df3ca8faab1864970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba29ed0c6634d5c8a3509aaf067d4f2"><td class="memItemLeft" align="right" valign="top"><a id="ga0ba29ed0c6634d5c8a3509aaf067d4f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga0ba29ed0c6634d5c8a3509aaf067d4f2">pystring::isalnum</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga0ba29ed0c6634d5c8a3509aaf067d4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all characters in the string are alphanumeric and there is at least one character, false otherwise. <br /></td></tr>
<tr class="separator:ga0ba29ed0c6634d5c8a3509aaf067d4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e4b9f7f4360b31c09fd6ac1af03173"><td class="memItemLeft" align="right" valign="top"><a id="ga46e4b9f7f4360b31c09fd6ac1af03173"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga46e4b9f7f4360b31c09fd6ac1af03173">pystring::isalpha</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga46e4b9f7f4360b31c09fd6ac1af03173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all characters in the string are alphabetic and there is at least one character, false otherwise. <br /></td></tr>
<tr class="separator:ga46e4b9f7f4360b31c09fd6ac1af03173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853aa78fbafe28c698bc05f1c0370e49"><td class="memItemLeft" align="right" valign="top"><a id="ga853aa78fbafe28c698bc05f1c0370e49"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga853aa78fbafe28c698bc05f1c0370e49">pystring::isdigit</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga853aa78fbafe28c698bc05f1c0370e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all characters in the string are digits and there is at least one character, false otherwise. <br /></td></tr>
<tr class="separator:ga853aa78fbafe28c698bc05f1c0370e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1418f7184ef8e80729d654d7114b63f9"><td class="memItemLeft" align="right" valign="top"><a id="ga1418f7184ef8e80729d654d7114b63f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga1418f7184ef8e80729d654d7114b63f9">pystring::islower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga1418f7184ef8e80729d654d7114b63f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all cased characters in the string are lowercase and there is at least one cased character, false otherwise. <br /></td></tr>
<tr class="separator:ga1418f7184ef8e80729d654d7114b63f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4010d798c9f258d2544474b5d1f23151"><td class="memItemLeft" align="right" valign="top"><a id="ga4010d798c9f258d2544474b5d1f23151"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga4010d798c9f258d2544474b5d1f23151">pystring::isspace</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga4010d798c9f258d2544474b5d1f23151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are only whitespace characters in the string and there is at least one character, false otherwise. <br /></td></tr>
<tr class="separator:ga4010d798c9f258d2544474b5d1f23151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d5dc700c7fd779392aa128e6fb84ea"><td class="memItemLeft" align="right" valign="top"><a id="ga97d5dc700c7fd779392aa128e6fb84ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga97d5dc700c7fd779392aa128e6fb84ea">pystring::istitle</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga97d5dc700c7fd779392aa128e6fb84ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the string is a titlecased string and there is at least one character, i.e. uppercase characters may only follow uncased characters and lowercase characters only cased ones. Return false otherwise. <br /></td></tr>
<tr class="separator:ga97d5dc700c7fd779392aa128e6fb84ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242a07ad2d480d51ffcd4a08808d78e1"><td class="memItemLeft" align="right" valign="top"><a id="ga242a07ad2d480d51ffcd4a08808d78e1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga242a07ad2d480d51ffcd4a08808d78e1">pystring::isupper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga242a07ad2d480d51ffcd4a08808d78e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all cased characters in the string are uppercase and there is at least one cased character, false otherwise. <br /></td></tr>
<tr class="separator:ga242a07ad2d480d51ffcd4a08808d78e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7d13c56dfefc6ac12eec84e37f9509a"><td class="memItemLeft" align="right" valign="top"><a id="gae7d13c56dfefc6ac12eec84e37f9509a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gae7d13c56dfefc6ac12eec84e37f9509a">pystring::join</a> (const std::string &amp;str, const std::vector&lt; std::string &gt; &amp;seq)</td></tr>
<tr class="memdesc:gae7d13c56dfefc6ac12eec84e37f9509a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string which is the concatenation of the strings in the sequence seq. The separator between elements is the str argument. <br /></td></tr>
<tr class="separator:gae7d13c56dfefc6ac12eec84e37f9509a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96579f53a5ba0c936dffdf8dda664123"><td class="memItemLeft" align="right" valign="top"><a id="ga96579f53a5ba0c936dffdf8dda664123"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga96579f53a5ba0c936dffdf8dda664123">pystring::ljust</a> (const std::string &amp;str, int width)</td></tr>
<tr class="memdesc:ga96579f53a5ba0c936dffdf8dda664123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string left justified in a string of length width. Padding is done using spaces. The original string is returned if width is less than str.size(). <br /></td></tr>
<tr class="separator:ga96579f53a5ba0c936dffdf8dda664123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aff1991bab2a60c454bebab8a1c0fea"><td class="memItemLeft" align="right" valign="top"><a id="ga6aff1991bab2a60c454bebab8a1c0fea"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga6aff1991bab2a60c454bebab8a1c0fea">pystring::lower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga6aff1991bab2a60c454bebab8a1c0fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string converted to lowercase. <br /></td></tr>
<tr class="separator:ga6aff1991bab2a60c454bebab8a1c0fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac9206c3aed9aaac085533a9fdf9de9b"><td class="memItemLeft" align="right" valign="top"><a id="gaac9206c3aed9aaac085533a9fdf9de9b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gaac9206c3aed9aaac085533a9fdf9de9b">pystring::lstrip</a> (const std::string &amp;str, const std::string &amp;chars=&quot;&quot;)</td></tr>
<tr class="memdesc:gaac9206c3aed9aaac085533a9fdf9de9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string with leading characters removed. If chars is omitted or None, whitespace characters are removed. If given and not "", chars must be a string; the characters in the string will be stripped from the beginning of the string this method is called on (argument "str" ). <br /></td></tr>
<tr class="separator:gaac9206c3aed9aaac085533a9fdf9de9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427bf41956257a973b70241ae2541fc8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga427bf41956257a973b70241ae2541fc8">pystring::mul</a> (const std::string &amp;str, int n)</td></tr>
<tr class="memdesc:ga427bf41956257a973b70241ae2541fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string, concatenated N times, together. Corresponds to the <b>mul</b> operator.  <a href="group__functions.html#ga427bf41956257a973b70241ae2541fc8">More...</a><br /></td></tr>
<tr class="separator:ga427bf41956257a973b70241ae2541fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23aac367ec1bf4d213dc92bdf36a9a7"><td class="memItemLeft" align="right" valign="top"><a id="gaa23aac367ec1bf4d213dc92bdf36a9a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gaa23aac367ec1bf4d213dc92bdf36a9a7">pystring::partition</a> (const std::string &amp;str, const std::string &amp;sep, std::vector&lt; std::string &gt; &amp;result)</td></tr>
<tr class="memdesc:gaa23aac367ec1bf4d213dc92bdf36a9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the string around first occurance of sep. Three strings will always placed into result. If sep is found, the strings will be the text before sep, sep itself, and the remaining text. If sep is not found, the original string will be returned with two empty strings. <br /></td></tr>
<tr class="separator:gaa23aac367ec1bf4d213dc92bdf36a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf7f01e937ec0af978577c1522205fe0"><td class="memItemLeft" align="right" valign="top"><a id="gabf7f01e937ec0af978577c1522205fe0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gabf7f01e937ec0af978577c1522205fe0">pystring::replace</a> (const std::string &amp;str, const std::string &amp;oldstr, const std::string &amp;newstr, int count=-1)</td></tr>
<tr class="memdesc:gabf7f01e937ec0af978577c1522205fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. <br /></td></tr>
<tr class="separator:gabf7f01e937ec0af978577c1522205fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3d5f650233ba6956190087894eb231"><td class="memItemLeft" align="right" valign="top"><a id="ga3a3d5f650233ba6956190087894eb231"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga3a3d5f650233ba6956190087894eb231">pystring::rfind</a> (const std::string &amp;str, const std::string &amp;sub, int start=0, int end=MAX_32BIT_INT)</td></tr>
<tr class="memdesc:ga3a3d5f650233ba6956190087894eb231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the highest index in the string where substring sub is found, such that sub is contained within s[start,end]. Optional arguments start and end are interpreted as in slice notation. Return -1 on failure. <br /></td></tr>
<tr class="separator:ga3a3d5f650233ba6956190087894eb231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2acb5704ed0b0aaa7d0df894649383"><td class="memItemLeft" align="right" valign="top"><a id="ga0f2acb5704ed0b0aaa7d0df894649383"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga0f2acb5704ed0b0aaa7d0df894649383">pystring::rindex</a> (const std::string &amp;str, const std::string &amp;sub, int start=0, int end=MAX_32BIT_INT)</td></tr>
<tr class="memdesc:ga0f2acb5704ed0b0aaa7d0df894649383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Currently a synonym of rfind. The python version raises exceptions. This one currently does not. <br /></td></tr>
<tr class="separator:ga0f2acb5704ed0b0aaa7d0df894649383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe16b100dd9f67cf767311cde888c3f"><td class="memItemLeft" align="right" valign="top"><a id="ga2fe16b100dd9f67cf767311cde888c3f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga2fe16b100dd9f67cf767311cde888c3f">pystring::rjust</a> (const std::string &amp;str, int width)</td></tr>
<tr class="memdesc:ga2fe16b100dd9f67cf767311cde888c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string right justified in a string of length width. Padding is done using spaces. The original string is returned if width is less than str.size(). <br /></td></tr>
<tr class="separator:ga2fe16b100dd9f67cf767311cde888c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf248895e32b8a30a6547eddbb6a2806"><td class="memItemLeft" align="right" valign="top"><a id="gabf248895e32b8a30a6547eddbb6a2806"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gabf248895e32b8a30a6547eddbb6a2806">pystring::rpartition</a> (const std::string &amp;str, const std::string &amp;sep, std::vector&lt; std::string &gt; &amp;result)</td></tr>
<tr class="memdesc:gabf248895e32b8a30a6547eddbb6a2806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the string around last occurance of sep. Three strings will always placed into result. If sep is found, the strings will be the text before sep, sep itself, and the remaining text. If sep is not found, the original string will be returned with two empty strings. <br /></td></tr>
<tr class="separator:gabf248895e32b8a30a6547eddbb6a2806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38fe026efcccd3b6a01fd9d6331ba90a"><td class="memItemLeft" align="right" valign="top"><a id="ga38fe026efcccd3b6a01fd9d6331ba90a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga38fe026efcccd3b6a01fd9d6331ba90a">pystring::rstrip</a> (const std::string &amp;str, const std::string &amp;chars=&quot;&quot;)</td></tr>
<tr class="memdesc:ga38fe026efcccd3b6a01fd9d6331ba90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string with trailing characters removed. If chars is "", whitespace characters are removed. If not "", the characters in the string will be stripped from the end of the string this method is called on. <br /></td></tr>
<tr class="separator:ga38fe026efcccd3b6a01fd9d6331ba90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50602a2df9ccf687d28e36816b7be661"><td class="memItemLeft" align="right" valign="top"><a id="ga50602a2df9ccf687d28e36816b7be661"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga50602a2df9ccf687d28e36816b7be661">pystring::split</a> (const std::string &amp;str, std::vector&lt; std::string &gt; &amp;result, const std::string &amp;sep=&quot;&quot;, int maxsplit=-1)</td></tr>
<tr class="memdesc:ga50602a2df9ccf687d28e36816b7be661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the "result" list with the words in the string, using sep as the delimiter string. If maxsplit is &gt; -1, at most maxsplit splits are done. If sep is "", any whitespace string is a separator. <br /></td></tr>
<tr class="separator:ga50602a2df9ccf687d28e36816b7be661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0dc152e5040be5e6c508fb74bcd291"><td class="memItemLeft" align="right" valign="top"><a id="gabf0dc152e5040be5e6c508fb74bcd291"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gabf0dc152e5040be5e6c508fb74bcd291">pystring::rsplit</a> (const std::string &amp;str, std::vector&lt; std::string &gt; &amp;result, const std::string &amp;sep=&quot;&quot;, int maxsplit=-1)</td></tr>
<tr class="memdesc:gabf0dc152e5040be5e6c508fb74bcd291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the "result" list with the words in the string, using sep as the delimiter string. Does a number of splits starting at the end of the string, the result still has the split strings in their original order. If maxsplit is &gt; -1, at most maxsplit splits are done. If sep is "", any whitespace string is a separator. <br /></td></tr>
<tr class="separator:gabf0dc152e5040be5e6c508fb74bcd291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e3fe91036ce4c56616aaa216313087"><td class="memItemLeft" align="right" valign="top"><a id="ga26e3fe91036ce4c56616aaa216313087"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga26e3fe91036ce4c56616aaa216313087">pystring::splitlines</a> (const std::string &amp;str, std::vector&lt; std::string &gt; &amp;result, bool keepends=false)</td></tr>
<tr class="memdesc:ga26e3fe91036ce4c56616aaa216313087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the lines in the string, breaking at line boundaries. Line breaks are not included in the resulting list unless keepends is given and true. <br /></td></tr>
<tr class="separator:ga26e3fe91036ce4c56616aaa216313087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad204e3461e963f5ce8d3f02089c0f746"><td class="memItemLeft" align="right" valign="top"><a id="gad204e3461e963f5ce8d3f02089c0f746"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gad204e3461e963f5ce8d3f02089c0f746">pystring::startswith</a> (const std::string &amp;str, const std::string &amp;prefix, int start=0, int end=MAX_32BIT_INT)</td></tr>
<tr class="memdesc:gad204e3461e963f5ce8d3f02089c0f746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return True if string starts with the prefix, otherwise return False. With optional start, test string beginning at that position. With optional end, stop comparing string at that position. <br /></td></tr>
<tr class="separator:gad204e3461e963f5ce8d3f02089c0f746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94cb1953ac6cd9432241fabf952543a3"><td class="memItemLeft" align="right" valign="top"><a id="ga94cb1953ac6cd9432241fabf952543a3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga94cb1953ac6cd9432241fabf952543a3">pystring::strip</a> (const std::string &amp;str, const std::string &amp;chars=&quot;&quot;)</td></tr>
<tr class="memdesc:ga94cb1953ac6cd9432241fabf952543a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string with leading and trailing characters removed. If chars is "", whitespace characters are removed. If given not "", the characters in the string will be stripped from the both ends of the string this method is called on. <br /></td></tr>
<tr class="separator:ga94cb1953ac6cd9432241fabf952543a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ef51266a9cd3564a86061670071065e"><td class="memItemLeft" align="right" valign="top"><a id="ga1ef51266a9cd3564a86061670071065e"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga1ef51266a9cd3564a86061670071065e">pystring::swapcase</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga1ef51266a9cd3564a86061670071065e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string with uppercase characters converted to lowercase and vice versa. <br /></td></tr>
<tr class="separator:ga1ef51266a9cd3564a86061670071065e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc7b8d5cd19df51947979e4e3d1d0e9"><td class="memItemLeft" align="right" valign="top"><a id="ga6dc7b8d5cd19df51947979e4e3d1d0e9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga6dc7b8d5cd19df51947979e4e3d1d0e9">pystring::title</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga6dc7b8d5cd19df51947979e4e3d1d0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase. <br /></td></tr>
<tr class="separator:ga6dc7b8d5cd19df51947979e4e3d1d0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9bd2f2c2f930551f77307e5ac0fc97"><td class="memItemLeft" align="right" valign="top"><a id="ga9a9bd2f2c2f930551f77307e5ac0fc97"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga9a9bd2f2c2f930551f77307e5ac0fc97">pystring::translate</a> (const std::string &amp;str, const std::string &amp;table, const std::string &amp;deletechars=&quot;&quot;)</td></tr>
<tr class="memdesc:ga9a9bd2f2c2f930551f77307e5ac0fc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table, which must be a string of length 256. <br /></td></tr>
<tr class="separator:ga9a9bd2f2c2f930551f77307e5ac0fc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed86d9a024fc8f6f6c1a2dbb56c721f"><td class="memItemLeft" align="right" valign="top"><a id="gaaed86d9a024fc8f6f6c1a2dbb56c721f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gaaed86d9a024fc8f6f6c1a2dbb56c721f">pystring::upper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaaed86d9a024fc8f6f6c1a2dbb56c721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the string converted to uppercase. <br /></td></tr>
<tr class="separator:gaaed86d9a024fc8f6f6c1a2dbb56c721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1602020fa3c6c734b2b662bdbc32f877"><td class="memItemLeft" align="right" valign="top"><a id="ga1602020fa3c6c734b2b662bdbc32f877"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga1602020fa3c6c734b2b662bdbc32f877">pystring::zfill</a> (const std::string &amp;str, int width)</td></tr>
<tr class="memdesc:ga1602020fa3c6c734b2b662bdbc32f877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the numeric string left filled with zeros in a string of length width. The original string is returned if width is less than str.size(). <br /></td></tr>
<tr class="separator:ga1602020fa3c6c734b2b662bdbc32f877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45e97a9184eeaefa35756e649cb8b666"><td class="memItemLeft" align="right" valign="top"><a id="ga45e97a9184eeaefa35756e649cb8b666"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga45e97a9184eeaefa35756e649cb8b666">pystring::slice</a> (const std::string &amp;str, int start=0, int end=MAX_32BIT_INT)</td></tr>
<tr class="memdesc:ga45e97a9184eeaefa35756e649cb8b666"><td class="mdescLeft">&#160;</td><td class="mdescRight">function matching python's slice functionality. <br /></td></tr>
<tr class="separator:ga45e97a9184eeaefa35756e649cb8b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6a1505184ee99c7efac3a62f3a4351"><td class="memItemLeft" align="right" valign="top"><a id="gafd6a1505184ee99c7efac3a62f3a4351"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gafd6a1505184ee99c7efac3a62f3a4351">pystring::os::path::basename</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:gafd6a1505184ee99c7efac3a62f3a4351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base name of pathname path. This is the second half of the pair returned by split(path). Note that the result of this function is different from the Unix basename program; where basename for '/foo/bar/' returns 'bar', the <a class="el" href="group__functions.html#gafd6a1505184ee99c7efac3a62f3a4351" title="Return the base name of pathname path. This is the second half of the pair returned by split(path)....">basename()</a> function returns an empty string (''). <br /></td></tr>
<tr class="separator:gafd6a1505184ee99c7efac3a62f3a4351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6f0ae920370c604330658b61148490"><td class="memItemLeft" align="right" valign="top"><a id="ga3a6f0ae920370c604330658b61148490"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::basename_nt</b> (const std::string &amp;path)</td></tr>
<tr class="separator:ga3a6f0ae920370c604330658b61148490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7522ffc9758e1166bd554500ba254395"><td class="memItemLeft" align="right" valign="top"><a id="ga7522ffc9758e1166bd554500ba254395"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::basename_posix</b> (const std::string &amp;path)</td></tr>
<tr class="separator:ga7522ffc9758e1166bd554500ba254395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09675271bb0ea069fbed09db821763e4"><td class="memItemLeft" align="right" valign="top"><a id="ga09675271bb0ea069fbed09db821763e4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga09675271bb0ea069fbed09db821763e4">pystring::os::path::dirname</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ga09675271bb0ea069fbed09db821763e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the directory name of pathname path. This is the first half of the pair returned by split(path). <br /></td></tr>
<tr class="separator:ga09675271bb0ea069fbed09db821763e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6fe1064def30d24097339e2f1af4edc"><td class="memItemLeft" align="right" valign="top"><a id="gaa6fe1064def30d24097339e2f1af4edc"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::dirname_nt</b> (const std::string &amp;path)</td></tr>
<tr class="separator:gaa6fe1064def30d24097339e2f1af4edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52939b862cd2f0995ae15d7d907dceaa"><td class="memItemLeft" align="right" valign="top"><a id="ga52939b862cd2f0995ae15d7d907dceaa"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::dirname_posix</b> (const std::string &amp;path)</td></tr>
<tr class="separator:ga52939b862cd2f0995ae15d7d907dceaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaccbc717a7278efd7034cac76b0c7e0"><td class="memItemLeft" align="right" valign="top"><a id="gacaccbc717a7278efd7034cac76b0c7e0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gacaccbc717a7278efd7034cac76b0c7e0">pystring::os::path::isabs</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:gacaccbc717a7278efd7034cac76b0c7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return True if path is an absolute pathname. On Unix, that means it begins with a slash, on Windows that it begins with a (back)slash after chopping off a potential drive letter. <br /></td></tr>
<tr class="separator:gacaccbc717a7278efd7034cac76b0c7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf1c73431cdbc026403b50165ac0260"><td class="memItemLeft" align="right" valign="top"><a id="gabcf1c73431cdbc026403b50165ac0260"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::isabs_nt</b> (const std::string &amp;path)</td></tr>
<tr class="separator:gabcf1c73431cdbc026403b50165ac0260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1096ab2bec1c2656e1501ba603b67ad"><td class="memItemLeft" align="right" valign="top"><a id="gae1096ab2bec1c2656e1501ba603b67ad"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::isabs_posix</b> (const std::string &amp;s)</td></tr>
<tr class="separator:gae1096ab2bec1c2656e1501ba603b67ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18abed60339fb62457763ea0b82d0930"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga18abed60339fb62457763ea0b82d0930">pystring::os::path::abspath</a> (const std::string &amp;path, const std::string &amp;cwd)</td></tr>
<tr class="memdesc:ga18abed60339fb62457763ea0b82d0930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a normalized absolutized version of the pathname path.  <a href="group__functions.html#ga18abed60339fb62457763ea0b82d0930">More...</a><br /></td></tr>
<tr class="separator:ga18abed60339fb62457763ea0b82d0930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7844cefbf9d0c4096395413b7300093"><td class="memItemLeft" align="right" valign="top"><a id="gaf7844cefbf9d0c4096395413b7300093"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::abspath_nt</b> (const std::string &amp;path, const std::string &amp;cwd)</td></tr>
<tr class="separator:gaf7844cefbf9d0c4096395413b7300093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6fd93ba5407464546b6fc04675e4b1"><td class="memItemLeft" align="right" valign="top"><a id="ga5a6fd93ba5407464546b6fc04675e4b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::abspath_posix</b> (const std::string &amp;path, const std::string &amp;cwd)</td></tr>
<tr class="separator:ga5a6fd93ba5407464546b6fc04675e4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73f1c440fc5193f2bf785ca489f7f2e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga73f1c440fc5193f2bf785ca489f7f2e9">pystring::os::path::join</a> (const std::string &amp;path1, const std::string &amp;path2)</td></tr>
<tr class="memdesc:ga73f1c440fc5193f2bf785ca489f7f2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join one or more path components intelligently. If any component is an absolute path, all previous components (on Windows, including the previous drive letter, if there was one) are thrown away, and joining continues. The return value is the concatenation of path1, and optionally path2, etc., with exactly one directory separator (os.sep) inserted between components, unless path2 is empty. Note that on Windows, since there is a current directory for each drive, os.path.join("c:", "foo") represents a path relative to the current directory on drive C: (c:foo), not c:\foo.  <a href="group__functions.html#ga73f1c440fc5193f2bf785ca489f7f2e9">More...</a><br /></td></tr>
<tr class="separator:ga73f1c440fc5193f2bf785ca489f7f2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41364bcd04240f05e12924a8e941b025"><td class="memItemLeft" align="right" valign="top"><a id="ga41364bcd04240f05e12924a8e941b025"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::join_nt</b> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="separator:ga41364bcd04240f05e12924a8e941b025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52244eceacdca762f252223689cab65d"><td class="memItemLeft" align="right" valign="top"><a id="ga52244eceacdca762f252223689cab65d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::join_posix</b> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="separator:ga52244eceacdca762f252223689cab65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga901660e76e88c0ddb4f007914e526d13"><td class="memItemLeft" align="right" valign="top"><a id="ga901660e76e88c0ddb4f007914e526d13"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::join</b> (const std::vector&lt; std::string &gt; &amp;paths)</td></tr>
<tr class="separator:ga901660e76e88c0ddb4f007914e526d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac034c129b9b618f2980f0359f2e018a9"><td class="memItemLeft" align="right" valign="top"><a id="gac034c129b9b618f2980f0359f2e018a9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::join_nt</b> (const std::vector&lt; std::string &gt; &amp;paths)</td></tr>
<tr class="separator:gac034c129b9b618f2980f0359f2e018a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc79d0b791269ab6d0614dbc838429d9"><td class="memItemLeft" align="right" valign="top"><a id="gafc79d0b791269ab6d0614dbc838429d9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::join_posix</b> (const std::vector&lt; std::string &gt; &amp;paths)</td></tr>
<tr class="separator:gafc79d0b791269ab6d0614dbc838429d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99efba1f452cd95cb14b963c168ede5"><td class="memItemLeft" align="right" valign="top"><a id="gad99efba1f452cd95cb14b963c168ede5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#gad99efba1f452cd95cb14b963c168ede5">pystring::os::path::normpath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:gad99efba1f452cd95cb14b963c168ede5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a pathname. This collapses redundant separators and up-level references so that A//B, A/B/, A/./B and A/foo/../B all become A/B. It does not normalize the case (use normcase() for that). On Windows, it converts forward slashes to backward slashes. It should be understood that this may change the meaning of the path if it contains symbolic links! <br /></td></tr>
<tr class="separator:gad99efba1f452cd95cb14b963c168ede5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59650ac1a986a73f1c67c00193dcbc7"><td class="memItemLeft" align="right" valign="top"><a id="gac59650ac1a986a73f1c67c00193dcbc7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::normpath_nt</b> (const std::string &amp;p)</td></tr>
<tr class="separator:gac59650ac1a986a73f1c67c00193dcbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689e3c992d9e2b10677e03fd1855d949"><td class="memItemLeft" align="right" valign="top"><a id="ga689e3c992d9e2b10677e03fd1855d949"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::normpath_posix</b> (const std::string &amp;p)</td></tr>
<tr class="separator:ga689e3c992d9e2b10677e03fd1855d949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga078b83e2e292a8a6c223ee00d8953200"><td class="memItemLeft" align="right" valign="top"><a id="ga078b83e2e292a8a6c223ee00d8953200"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga078b83e2e292a8a6c223ee00d8953200">pystring::os::path::split</a> (std::string &amp;head, std::string &amp;tail, const std::string &amp;path)</td></tr>
<tr class="memdesc:ga078b83e2e292a8a6c223ee00d8953200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the pathname path into a pair, (head, tail) where tail is the last pathname component and head is everything leading up to that. The tail part will never contain a slash; if path ends in a slash, tail will be empty. If there is no slash in path, head will be empty. If path is empty, both head and tail are empty. Trailing slashes are stripped from head unless it is the root (one or more slashes only). In all cases, join(head, tail) returns a path to the same location as path (but the strings may differ). <br /></td></tr>
<tr class="separator:ga078b83e2e292a8a6c223ee00d8953200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ae98e211d596167d0c4c142d85274e"><td class="memItemLeft" align="right" valign="top"><a id="ga44ae98e211d596167d0c4c142d85274e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::split_nt</b> (std::string &amp;head, std::string &amp;tail, const std::string &amp;path)</td></tr>
<tr class="separator:ga44ae98e211d596167d0c4c142d85274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c3d5c5cedd87856c0534f7a783ef6e"><td class="memItemLeft" align="right" valign="top"><a id="ga48c3d5c5cedd87856c0534f7a783ef6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::split_posix</b> (std::string &amp;head, std::string &amp;tail, const std::string &amp;p)</td></tr>
<tr class="separator:ga48c3d5c5cedd87856c0534f7a783ef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3b3aba797f8e7df2cffca6d131ed67"><td class="memItemLeft" align="right" valign="top"><a id="ga7a3b3aba797f8e7df2cffca6d131ed67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga7a3b3aba797f8e7df2cffca6d131ed67">pystring::os::path::splitdrive</a> (std::string &amp;drivespec, std::string &amp;pathspec, const std::string &amp;path)</td></tr>
<tr class="memdesc:ga7a3b3aba797f8e7df2cffca6d131ed67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the pathname path into a pair (drive, tail) where drive is either a drive specification or the empty string. On systems which do not use drive specifications, drive will always be the empty string. In all cases, drive + tail will be the same as path. <br /></td></tr>
<tr class="separator:ga7a3b3aba797f8e7df2cffca6d131ed67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aac2aaea50f268229106d6328fd566a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga3aac2aaea50f268229106d6328fd566a">pystring::os::path::splitdrive_nt</a> (std::string &amp;drivespec, std::string &amp;pathspec, const std::string &amp;p)</td></tr>
<tr class="separator:ga3aac2aaea50f268229106d6328fd566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5915939f8803e142d5e4e66f22fb2043"><td class="memItemLeft" align="right" valign="top"><a id="ga5915939f8803e142d5e4e66f22fb2043"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::splitdrive_posix</b> (std::string &amp;drivespec, std::string &amp;pathspec, const std::string &amp;path)</td></tr>
<tr class="separator:ga5915939f8803e142d5e4e66f22fb2043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd47897e6baddc60afdae984bb98687"><td class="memItemLeft" align="right" valign="top"><a id="ga5fd47897e6baddc60afdae984bb98687"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__functions.html#ga5fd47897e6baddc60afdae984bb98687">pystring::os::path::splitext</a> (std::string &amp;root, std::string &amp;ext, const std::string &amp;path)</td></tr>
<tr class="memdesc:ga5fd47897e6baddc60afdae984bb98687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the pathname path into a pair (root, ext) such that root + ext == path, and ext is empty or begins with a period and contains at most one period. Leading periods on the basename are ignored; splitext('.cshrc') returns ('.cshrc', ''). <br /></td></tr>
<tr class="separator:ga5fd47897e6baddc60afdae984bb98687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f10a903b5919d1389842ca66912114"><td class="memItemLeft" align="right" valign="top"><a id="gaf2f10a903b5919d1389842ca66912114"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::splitext_nt</b> (std::string &amp;root, std::string &amp;ext, const std::string &amp;path)</td></tr>
<tr class="separator:gaf2f10a903b5919d1389842ca66912114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb25a8f5640f3b4b334e1b10028a95e"><td class="memItemLeft" align="right" valign="top"><a id="ga1bb25a8f5640f3b4b334e1b10028a95e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pystring::os::path::splitext_posix</b> (std::string &amp;root, std::string &amp;ext, const std::string &amp;path)</td></tr>
<tr class="separator:ga1bb25a8f5640f3b4b334e1b10028a95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga18abed60339fb62457763ea0b82d0930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18abed60339fb62457763ea0b82d0930">&#9670;&nbsp;</a></span>abspath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pystring::os::path::abspath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cwd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a normalized absolutized version of the pathname path. </p>
<p>NOTE: This differs from the interface of the python equivalent in that it requires you to pass in the current working directory as an argument. </p>

</div>
</div>
<a id="ga73f1c440fc5193f2bf785ca489f7f2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73f1c440fc5193f2bf785ca489f7f2e9">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pystring::os::path::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join one or more path components intelligently. If any component is an absolute path, all previous components (on Windows, including the previous drive letter, if there was one) are thrown away, and joining continues. The return value is the concatenation of path1, and optionally path2, etc., with exactly one directory separator (os.sep) inserted between components, unless path2 is empty. Note that on Windows, since there is a current directory for each drive, os.path.join("c:", "foo") represents a path relative to the current directory on drive C: (c:foo), not c:\foo. </p>
<p>This dispatches based on the compilation OS </p>

</div>
</div>
<a id="ga427bf41956257a973b70241ae2541fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga427bf41956257a973b70241ae2541fc8">&#9670;&nbsp;</a></span>mul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pystring::mul </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of the string, concatenated N times, together. Corresponds to the <b>mul</b> operator. </p>

</div>
</div>
<a id="ga3aac2aaea50f268229106d6328fd566a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aac2aaea50f268229106d6328fd566a">&#9670;&nbsp;</a></span>splitdrive_nt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pystring::os::path::splitdrive_nt </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>drivespec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>pathspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These functions are C++ ports of the python2.6 versions of os.path, and come from genericpath.py, ntpath.py, posixpath.py Split a pathname into drive and path specifiers. Returns drivespec, pathspec. Either part may be empty. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
